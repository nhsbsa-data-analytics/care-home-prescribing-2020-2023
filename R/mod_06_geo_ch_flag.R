mod_06_geo_ch_flag_ui <- function(id) {
  ns <- NS(id)
  
  tagList(
    include_dynamic_md("inst/markdown/06_geo_ch_flag.md"),
    nhs_card(
      heading = "Estimated prescribing metrics for care home vs non-care home
                 patients aged 65 years and over in England",
      div(
        class = "nhsuk-grid-row",
        div(
          class = "nhsuk-grid-column-one-third",
          nhs_selectInput(
            inputId = ns("fy"),
            label = "Financial year",
            choices = carehomes2::metrics_by_geo_and_ch_flag_df$FY %>%
              levels(),
            selected = carehomes2::metrics_by_geo_and_ch_flag_df$FY %>%
              levels() %>%
              max(),
            full_width = TRUE
          )
        ),
        div(
          class = "nhsuk-grid-column-one-third",
          nhs_selectInput(
            inputId = ns("metric"),
            label = "Metric",
            choices = c(
              "Mean drug cost PPM" = "COST_PPM",
              "Mean prescription items PPM" = "ITEMS_PPM",
              "Mean unique medicines PPM" = "UNIQ_MEDS_PPM",
              "% of patient-months with 6+ unique medicines" = "PCT_PM_GTE_SIX",
              "% of patient-months with 10+ unique medicines" = "PCT_PM_GTE_TEN",
              "% of patient-months with 2+ ACB medicines" = "PCT_PM_ACB",
              "% of patient-months with 2+ DAMN medicines" = "PCT_PM_DAMN",
              "Mean unique falls risk medicines PPM" = "UNIQ_MEDS_FALLS_PPM",
              "% of patient-months with 3+ falls risk medicines" = "PCT_PM_FALLS"
            ),
            full_width = TRUE
          )
        ),
        div(
          class = "nhsuk-grid-column-one-third",
          nhs_selectInput(
            inputId = ns("geography"),
            label = "Geography",
            choices = names(geographies)[-1],
            full_width = TRUE
          )
        )
      ),
      nhs_grid_2_col(
        highcharter::highchartOutput(ns("map_ch"), height = "500px"),
        highcharter::highchartOutput(ns("map_non_ch"), height = "500px")
      ),
      shinyWidgets::radioGroupButtons(
        inputId = ns("table_sort_by"),
        label = "Sort areas by the value for:",
        choices = c("Care home", "Non-care home"),
        selected = "Care home",
        justified = TRUE
      ),
      DT::DTOutput(ns("main_table")),
      DT::DTOutput(ns("footer_table")),
      tags$text(
        class = "highcharts-caption",
        style = "font-size: 9pt;",
        "Clicking a 'Care home' or 'Non-care home' row in the table will outline
         the relevant area on the maps.",
        tags$br(),
        "The Isles of Scilly were removed due to the number of care homes in the
         Local Authority.",
        tags$br(),
        "Mean drug cost PPM is rounded to the nearest GBP. All other values 
        are rounded to 2 decimal places."
      )
    ),
    tags$div(style = "margin-top: 25vh") # Some buffer space after the chart
  )
}

mod_06_geo_ch_flag_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # Metric name mappings ------------------------------------------------
    
    # Map metric column names to UI metric names
    ui_metric_names <- c(
      COST_PPM            = "Mean drug cost PPM",
      ITEMS_PPM           = "Mean prescription items PPM",
      UNIQ_MEDS_PPM       = "Mean unique medicines PPM",
      PCT_PM_GTE_SIX      = "% of patient-months with 6+ unique medicines",
      PCT_PM_GTE_TEN      = "% of patient-months with 10+ unique medicines",
      PCT_PM_ACB          = "% of patient-months with 2+ ACB medicines",
      PCT_PM_DAMN         = "% of patient-months with 2+ DAMN medicines",
      UNIQ_MEDS_FALLS_PPM = "Mean unique falls risk medicines PPM",
      PCT_PM_FALLS        = "% of patient-months with 3+ falls risk medicines"
    )
    
    # Map metric column names to tooltip metric names
    metric_tooltips <- c(
      COST_PPM            = "<b>Mean drug cost PPM</b> \u00A3{point.value}",
      ITEMS_PPM           = "<b>Mean prescription items PPM:</b> {point.value:.2f}",
      UNIQ_MEDS_PPM       = "<b>Mean unique medicines PPM:</b> {point.value:.2f}",
      PCT_PM_GTE_SIX      = "<b>% of patient-months with 6+ unique medicines:</b> {point.value:.2f}%",
      PCT_PM_GTE_TEN      = "<b>% of patient-months with 10+ unique medicines:</b> {point.value:.2f}%",
      PCT_PM_ACB          = "<b>% of patient-months with 2+ ACB medicines:</b> {point.value:.2f}%",
      PCT_PM_DAMN         = "<b>% of patient-months with 2+ DAMN medicines:</b> {point.value:.2f}%",
      UNIQ_MEDS_FALLS_PPM = "<b>Mean unique falls risk medicines PPM:</b> {point.value:.2f}",
      PCT_PM_FALLS        = "<b>% of patient-months with 3+ falls risk medicines:</b> {point.value:.2f}%"
    )
    
    # Map all column names to download data names
    dl_col_names <- c(
      rlang::set_names(names(ui_metric_names), unname(ui_metric_names)),
      "Financial year"                      = "FY",
      "Geography"                           = "GEOGRAPHY",
      "Sub-geography code"                  = "SUB_GEOGRAPHY_CODE",
      "Sub-geography name"                  = "SUB_GEOGRAPHY_NAME",
      "Care home status"                    = "CH_FLAG"
    )
    
    # Formatted data ------------------------------------------------------
    
    fmt_data <- carehomes2::metrics_by_geo_and_ch_flag_df %>% 
      dplyr::filter(SUB_GEOGRAPHY_NAME != "Isles of Scilly") %>% 
      dplyr::mutate(
        dplyr::across(
          c(dplyr::ends_with("_PPM"), dplyr::starts_with("PCT_")),
          \(x) janitor::round_half_up(x, 2)
        ),
        COST_PPM = janitor::round_half_up(COST_PPM, 0)
      )
    
    # Reactive data -------------------------------------------------------
    
    fdata <- reactive({
      initial_data <- fmt_data %>%
        dplyr::filter(
          .data$GEOGRAPHY == input$geography,
          .data$FY == input$fy
        ) %>% 
        dplyr::mutate(
          .data$GEOGRAPHY,
          .data$SUB_GEOGRAPHY_NAME,
          .data$SUB_GEOGRAPHY_CODE,
          .data[[input$metric]],
          .data$CH_FLAG,
          .keep = "none"
        )
    })
    
    map_data <- reactive(carehomes2::geo_data[[input$geography]])
    
    
    
    # Output functions ----------------------------------------------------
    
    # Create map
    create_map <- function(data,
                           map_data,
                           ch_status = c("Care home", "Non-care home")) {
      # City of London has no care home activity, so will have 0 for all metrics.
      # This should be treated as not existing when setting limits of the colour
      # scale.
      fmt_data_no_city_of_london <- fmt_data %>% 
        dplyr::filter(SUB_GEOGRAPHY_NAME != "City of London")
      
      # Note that the final displayed limits will not exactly match the min and
      # max values - highcharts will pick appropriate numbers close to the limits
      color_axis_limits <- list(
        min = fmt_data_no_city_of_london[[input$metric]] %>%
          min(na.rm = TRUE),
        max = fmt_data_no_city_of_london[[input$metric]] %>% 
          max(na.rm = TRUE)
      )
      
      ifelse(
        ch_status == "Care home",
        data <- data %>% dplyr::filter(.data$CH_FLAG),
        data <- data %>% dplyr::filter(!.data$CH_FLAG)
      )
      
      highcharter::highchart() %>%
        highcharter::hc_add_series_map(
          df = data,
          map = map_data,
          joinBy = "SUB_GEOGRAPHY_CODE",
          value = input$metric,
          tooltip = list(
            useHTML = TRUE,
            headerFormat = "",
            pointFormat = paste0(
              tags$b(input$geography, ": "), "{point.SUB_GEOGRAPHY_NAME}",
              tags$br(),
              metric_tooltips[input$metric] %>% unname()
            )
          ),
          borderWidth = 0,
          borderColor = 'black'
        ) %>%
        nhsbsaR::theme_nhsbsa_highchart() %>%
        highcharter::hc_mapNavigation(
          enabled = TRUE,
          enableMouseWheelZoom = TRUE,
          enableDoubleClickZoom = TRUE
        ) %>%
        highcharter::hc_colorAxis(
          min = color_axis_limits$min,
          max = color_axis_limits$max,
          stops = list(
            c(0, NHSRtheme::get_nhs_colours("DarkBlue") |> unname()),
            c(0.4, NHSRtheme::get_nhs_colours("LightBlue") |> unname()),
            c(0.5, NHSRtheme::get_nhs_colours("Yellow") |> unname()),
            c(0.6, NHSRtheme::get_nhs_colours("WarmYellow") |> unname()),
            c(1, NHSRtheme::get_nhs_colours("Red") |> unname())
          )
        ) %>%
        highcharter::hc_title(text = ch_status)
    }
    
    
    # Create datatable
    # NOTE: There is no arrange on SUB_GEOGRAPHY_NAME. Original code did have 
    # this, but it turned out that the underlying data is not sorted. This meant
    # that JS code for map border highlighting was using a different order to 
    # what was shown in the table. It should be possible to align the order in 
    # JS with the order in an `arrange`d table, but in this case the data is 
    # already well-ordered, so best solution is to just remove arrange.
    create_datatable <- function(data, sort_on) {
      tdata_pre_sort <- data %>%
        dplyr::filter(.data$GEOGRAPHY == input$geography) %>%
        dplyr::group_by(.data$FY, .data$GEOGRAPHY) %>%
        dplyr::arrange(dplyr::desc(.data$CH_FLAG), .by_group = TRUE) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(
          !!rlang::sym(input$geography) := as.character(.data$SUB_GEOGRAPHY_NAME),
          `Area / Carehome status` = dplyr::case_match(
            .data$CH_FLAG,
            TRUE  ~ "Care home",
            FALSE ~ "Non-care home"
          ),
          MetricValue = .data[[input$metric]],
          FY,
          .keep = "none"
        ) %>%
        tidyr::pivot_wider(
          names_from = FY,
          values_from = MetricValue
        ) %>%
        dplyr::arrange(!!rlang::sym(input$geography))
      
      fy_cols <- names(tdata_pre_sort)[-c(1, 2)]
      
      mean_data <- tdata_pre_sort %>% 
        dplyr::summarise(
          !!rlang::sym(input$geography) := "National average",
          dplyr::across(
            dplyr::all_of(fy_cols),
            \(x) {
              out <- mean(x, na.rm = TRUE)
              if (grepl("cost", input$metric, ignore.case = TRUE)) {
                round(mean(out, na.rm = TRUE), 0)
              } else {
                round(mean(out, na.rm = TRUE), 2)
              }
            }
          ),
          .by = `Area / Carehome status`
        ) %>% 
        dplyr::select(!!rlang::sym(input$geography), dplyr::everything())
      
      tdata <- tdata_pre_sort %>%
        dplyr::mutate(
          dplyr::across(
            .cols = dplyr::all_of(fy_cols),
            .fns = ~ .[match(sort_on, `Area / Carehome status`)],
            .names = "{.col}_sort"
          ),
          .by = !!rlang::sym(input$geography)
        )

      # Callback to handle empty cells and display as NA
      rowCallback <- c(
        "function(row, data){",
        "  for(var i=0; i<data.length; i++){",
        "    if(data[i] === null){",
        "      $('td:eq('+i+')', row).html('NA')",
        "        .css({'color': 'rgb(151,151,151)', 'font-style': 'italic'});",
        "    }",
        "  }",
        "}"
      )

      visible_cols_indices <- which(names(tdata) %in% fy_cols) - 1 # 0-based index for JS
      sort_cols_indices <- which(names(tdata) %in% paste0(fy_cols, "_sort")) - 1

      order_defs <- lapply(seq_along(visible_cols_indices), function(i) {
        list(orderData = sort_cols_indices[i], targets = visible_cols_indices[i])
      })

      all_col_defs <- c(
        list(
          list(className = "dt-center", targets = "_all"),
          list(visible = FALSE, targets = 0),
          list(visible = FALSE, targets = sort_cols_indices),
          list(orderData = 0, targets = 1)
        ),
        order_defs
      )

      main_dt <- DT::datatable(
        tdata,
        rownames = FALSE,
        extensions = "RowGroup",
        selection = "single",
        options = list(
          dom = "ft",
          scrollCollapse = TRUE,
          paging = FALSE,
          scrollY = "350px",
          scrollX = TRUE,
          tabindex = "0",
          rowGroup = list(dataSrc = 0),
          columnDefs = all_col_defs,
          rowCallback = DT::JS(rowCallback),
          drawCallback = DT::JS(
            "function(settings) {",
            "  // Check if functions exist before calling, for safety.",
            "  if (typeof syncColumnWidths === 'function') { syncColumnWidths(); }",
            "  if (typeof syncScrolls === 'function') { syncScrolls(); }",
            "}"
          )
        )
      ) %>%
        DT::formatStyle(columns = 1:ncol(tdata), `font-size` = "12px")
      
      footer_dt <- DT::datatable(
        mean_data,
        rownames = FALSE,
        extensions = "RowGroup",
        selection = "none",
        options = list(
          dom = 't',
          scrollX = TRUE,
          paging = FALSE,
          ordering = FALSE,
          rowGroup = list(dataSrc = 0),
          columnDefs = list(
            list(visible = FALSE, targets = 0),
            list(className = "dt-center", targets = "_all")
          ),
          headerCallback = DT::JS(
            "function(thead, data, start, end, display) {",
            "  $(thead).empty();",
            "}"
          )
        )
      ) %>%
        DT::formatStyle(columns = 1:ncol(mean_data), `font-size` = "12px")
      
      list(main_table = main_dt, footer_table = footer_dt)
    }
    
    tables_list <- reactive({
      req(input$geography, input$metric, input$table_sort_by)
      
      create_datatable(data = fmt_data, sort_on = input$table_sort_by)
    })
    
    # Create download data (all data)
    create_download_data <- function(data) {
      data %>%
        dplyr::select(!dplyr::starts_with("TOTAL")) %>% 
        dplyr::mutate(
          CH_FLAG = ifelse(CH_FLAG, "Care home", "Non-care home")
        )  %>% 
        dplyr::arrange(
          .data$FY,
          .data$GEOGRAPHY,
          .data$SUB_GEOGRAPHY_NAME,
          data$CH_FLAG
        ) %>%
        dplyr::rename(dl_col_names)
    }
    
    # Outputs -------------------------------------------------------------
    
    # Maps
    output$map_ch <- highcharter::renderHighchart(
      create_map(fdata(), map_data(), "Care home")
    )
    output$map_non_ch <- highcharter::renderHighchart(
      create_map(fdata(), map_data(), "Non-care home")
    )
    
    output$main_table <- DT::renderDT({
      tables_list()$main_table
    })
    
    # Render the footer table from the list
    output$footer_table <- DT::renderDT({
      tables_list()$footer_table
    })
    
    # Download buttons
    mod_nhs_download_server(
      id = "download_data",
      filename = "Selected prescribing metrics by geography and care home status.xlsx",
      export_data = create_download_data(fmt_data)
    )
    
    
    # Reactive events -----------------------------------------------------
    
    # Need to track previously selected row to toggle border w/o searching whole
    # dataset
    previous_row_selected <- reactiveVal(NULL)
    
    # When a table row is clicked, fire a custom Shiny message to toggle the
    # border of the same map area.
    observe({
      if (!is.null(previous_row_selected())) {
        session$sendCustomMessage(
          type = 'rowClicked',
          message = list(
            # Need index - 1 since JavaScript is 0-indexed vs R 1-indexed
            previous_row = previous_row_selected() - 1,
            row = janitor::round_half_up(input$main_table_rows_selected / 2) - 1
          )
        )
      } 
      
      # Update previous selected row to be the current selected row
      previous_row_selected(janitor::round_half_up(input$main_table_rows_selected / 2))
    })
    
    observeEvent(
      fmt_data,
      once = TRUE, {
        req(fmt_data)
        
        insertUI(
          selector = ".nhsuk-card__description:eq(4)",
          where = "beforeEnd",
          ui = mod_nhs_download_ui(ns("download_data"))
        )
      })
  })
}
